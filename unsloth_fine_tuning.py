# -*- coding: utf-8 -*-
"""Copy of Unsloth.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1s6a3qeTh2VIZ8uFQKNUUyCJAjTmHFcsO
"""

# Commented out IPython magic to ensure Python compatibility.
# %%capture
# !pip install unsloth vllm
# !pip install --force-reinstall --no-cache-dir --no-deps git+https://github.com/unslothai/unsloth.git
# !pip install git+https://github.com/huggingface/transformers.git

!pip install bitsandbytes

pip install unsloth-zoo

import os
# os.environ['TRITON_DISABLE_LINE_INFO'] = '1' # Optional, tested with and without
os.environ['TRITON_JIT_DISABLE_OPT'] = '1' # Likely the most critical change

from google.colab import drive
drive.mount('/content/drive')

from unsloth import FastLanguageModel

model_name = "unsloth/Meta-Llama-3.1-8B-bnb-4bit"  # or 3.2, 70B, Instruct, etc.

model, tokenizer = FastLanguageModel.from_pretrained(
    model_name=model_name,
    max_seq_length=1024,
    load_in_4bit=True,  # use QLoRA
    dtype=None,
)

import os
os.environ["PROTOCOL_BUFFERS_PYTHON_IMPLEMENTATION"] = "python"

!pip uninstall -y protobuf sentencepiece
!pip install protobuf==3.20.3 sentencepiece --force-reinstall

from unsloth import FastLanguageModel
from unsloth.chat_templates import get_chat_template

model = FastLanguageModel.get_peft_model(
    model,
    r=16,
    lora_alpha=16,
    lora_dropout=0.0,
    target_modules=["q_proj","k_proj","v_proj","o_proj","gate_proj","up_proj","down_proj"],
    bias="none",
    use_gradient_checkpointing = False,
    use_rslora=False,
)
tokenizer = get_chat_template(tokenizer, chat_template="chatml")

import json
from datasets import Dataset

# Load your JSON dataset
with open("/content/drive/MyDrive/combined_dataset.json", "r", encoding="utf-8") as f:
    data = json.load(f)

# Convert to chat format
def format_example(entry):
    user_prompt = (
        f"Question: {entry['question']}\n"
        f"Rubric: {entry['rubric']}\n"
        f"Ideal Answer: {entry['ideal_answer']}\n"
        f"Student Answer: {entry['student_answer']}\n"
        f"Strategy: {entry['strategy']}"
    )
    assistant_response = f"Score: {entry['score']}\nReview: {entry['cot_review']}"
    return {
        "user": user_prompt,
        "assistant": assistant_response
    }

# Apply transformation
chat_data = [format_example(entry) for entry in data]
ds = Dataset.from_list(chat_data)

ds[0]

from unsloth import FastLanguageModel
from unsloth.chat_templates import get_chat_template

# Get tokenizer (assume already loaded)
tokenizer = get_chat_template(tokenizer, chat_template="chatml")

# Apply formatting to dataset
ds = ds.map(lambda example: {
    "text": tokenizer.apply_chat_template(
        [{"role": "user", "content": example["user"]},
         {"role": "assistant", "content": example["assistant"]}],
        tokenize=False
    )
})

from trl import SFTTrainer
from transformers import TrainingArguments

training_args = TrainingArguments(
    output_dir="./finetuned",
    per_device_train_batch_size=1,
    gradient_accumulation_steps=8,
    fp16 = False,
    num_train_epochs=1,
    learning_rate=3e-5,
    save_total_limit=2,
    logging_steps=10,
      # optional
    max_steps=250,
)


def formatting_func(examples):
    return {"text": examples["text"]}

trainer = SFTTrainer(
    model=model,
    train_dataset=ds, # Use the processed dataset `ds`
    args=training_args,
    tokenizer=tokenizer,
    formatting_func=formatting_func, # Add the formatting function
)

trainer.train()

trainer.save_model("/content/drive/MyDrive/fine-tuned-model1")

model.save_pretrained("llama3-grader")
tokenizer.save_pretrained("llama3-grader")

chat = [
    {"role": "user", "content": f"""
"Question": "What is the primary objective of requirements modeling, and how does it contribute to the software development process?",
    "Rubric": "A clear description of the primary objective of requirements modeling, including its role in describing customer requirements (3 marks)\nAn explanation of how requirements modeling establishes a basis for software design, including the importance of bridging the gap between system-level representation and software design (4 marks)\nA discussion of the role of requirements modeling in defining a set of requirements that can be validated once the software is built, including the significance of validation in the software development process (3 marks)",
    "Ideal Answer": "The primary objective of requirements modeling is to create a variety of representations that describe what the customer requires, establishing a basis for the creation of a software design, and defining a set of requirements that can be validated once the software is built. Requirements modeling plays a crucial role in bridging the gap between a system-level representation that describes overall system and business functionality and a software design. By doing so, it enables the development of a software design that meets the customer's requirements and ensures that the software functions as intended. Furthermore, requirements modeling defines a set of requirements that can be validated once the software is built, allowing for the verification of the software's functionality and performance. This validation is essential in ensuring that the software meets the customer's needs and is free from defects, ultimately contributing to the success of the software development process.",
    "Student Answer": "To be honest, I'm not entirely sure about the primary objective of requirements modeling, but from what I've gathered, it's basically about creating a bunch of diagrams and documents that describe what the customer wants. I think it's supposed to help us understand the customer's requirements, but I'm not really clear on how it does that. \n\nI've heard that requirements modeling is important for software design, but I don't really get how it bridges the gap between system-level representation and software design. I mean, isn't software design just about writing code? I'm not sure how requirements modeling fits into that. Maybe it's like, a way to make sure we're building the right thing, but I'm not really sure.\n\nAs for validation, I think requirements modeling is supposed to help us define a set of requirements that we can check against once the software is built. But, to be honest, I'm not really sure how that works or why it's important. I know validation is a thing, but I don't really understand its significance in the software development process. Can we come back to this later? I feel like I'm missing something. \n\nOh, and I think requirements modeling might also have something to do with, like, making sure the software is usable and stuff. But, yeah, that's about it. I'm pretty lost on this topic, sorry.",
    "Strategy": "clarification"
     Please evaluate the student's answer by assigning a score from 0 to 10 and providing a concise review.
Return only this format:
Score: <score from 0 to 10>
Review: <your feedback>
"""}
]

response = tokenizer.apply_chat_template(chat, tokenize=False, add_generation_prompt=True)
inputs = tokenizer(response, return_tensors="pt").to(model.device)
outputs = model.generate(**inputs, max_new_tokens=150)
print(tokenizer.decode(outputs[0], skip_special_tokens=True))

chat = [
    {"role": "user", "content": f"""
"Question": "What is dynamic programming and why is it useful in algorithm design?",
"Rubric": "A clear definition of dynamic programming, including its use of overlapping subproblems and optimal substructure (3 marks)\nAn explanation of how it differs from recursion and its efficiency benefits (4 marks)\nA discussion of its usefulness in solving problems like Fibonacci, knapsack, and matrix chain multiplication (3 marks)",
"Ideal Answer": "Dynamic programming (DP) is an algorithmic technique used to solve problems by breaking them down into simpler subproblems and storing their results to avoid redundant computations. It is applicable to problems with overlapping subproblems and optimal substructure. Unlike plain recursion, DP uses memoization or tabulation to improve efficiency, reducing time complexity significantly. For example, calculating Fibonacci numbers using recursion is exponential, while using DP makes it linear. DP is particularly useful in solving optimization problems like the 0/1 Knapsack, matrix chain multiplication, and longest common subsequence.",
"Student Answer": "Dynamic programming is like recursion but faster. It stores values so we don't repeat work. It’s used in problems like knapsack, I think. I'm not sure what optimal substructure means, but it helps in improving performance. I always get confused between top-down and bottom-up, but I know it’s useful.",
"Strategy": "clarification"
Please evaluate the student's answer by assigning a score from 0 to 10 and providing a concise review.
Return only this format:
Score: <score from 0 to 10>
Review: <your feedback>
"""}
]

response = tokenizer.apply_chat_template(chat, tokenize=False, add_generation_prompt=True)
inputs = tokenizer(response, return_tensors="pt").to(model.device)
outputs = model.generate(**inputs, max_new_tokens=150)
print(tokenizer.decode(outputs[0], skip_special_tokens=True))

chat = [
    {"role": "user", "content": f"""
"Question": "What is time complexity and why is it important in algorithm analysis?",
"Rubric": "A correct definition of time complexity in terms of input size and execution steps (3 marks)\nAn explanation of how time complexity is expressed using Big-O notation (4 marks)\nA discussion of why time complexity matters in evaluating algorithm efficiency and scalability (3 marks)",
"Ideal Answer": "Time complexity refers to the computational complexity that describes the amount of time an algorithm takes to run as a function of the input size. It helps us estimate how the algorithm performs as input grows. It is typically expressed using Big-O notation, such as O(n), O(log n), or O(n^2), which gives an upper bound on runtime. Time complexity is crucial for analyzing and comparing algorithms, especially for large inputs, since it affects performance, scalability, and feasibility.",
"Student Answer": "Time complexity is about how long a program takes to run. We use O notation like O(n), but I don’t fully understand what it means. I think it’s important because we don’t want the program to be slow. It helps compare algorithms, but I sometimes forget the different types like linear or quadratic.",
"Strategy": "clarification"
Please evaluate the student's answer by assigning a score from 0 to 10 and providing a concise review.
Return only this format:
Score: <score from 0 to 10>
Review: <your feedback>
"""}
]

response = tokenizer.apply_chat_template(chat, tokenize=False, add_generation_prompt=True)
inputs = tokenizer(response, return_tensors="pt").to(model.device)
outputs = model.generate(**inputs, max_new_tokens=150, eos_token_id=tokenizer.eos_token_id)
print(tokenizer.decode(outputs[0], skip_special_tokens=True))

from transformers import AutoTokenizer, AutoModelForCausalLM
import torch

# Load your saved fine-tuned model and tokenizer
model_path = "/content/drive/MyDrive/fine-tuned-model1"  # or your Hugging Face path
tokenizer = AutoTokenizer.from_pretrained(model_path)
model = AutoModelForCausalLM.from_pretrained(model_path, device_map="auto", torch_dtype=torch.float16)  # use float16 if it's a 4bit model

# Create the chat format (based on Hugging Face chat template compatibility)

chat = [
    {"role": "user", "content": f"""
"Question": "What is the primary objective of requirements modeling, and how does it contribute to the software development process?",
    "Rubric": "A clear description of the primary objective of requirements modeling, including its role in describing customer requirements (3 marks)\nAn explanation of how requirements modeling establishes a basis for software design, including the importance of bridging the gap between system-level representation and software design (4 marks)\nA discussion of the role of requirements modeling in defining a set of requirements that can be validated once the software is built, including the significance of validation in the software development process (3 marks)",
    "Ideal Answer": "The primary objective of requirements modeling is to create a variety of representations that describe what the customer requires, establishing a basis for the creation of a software design, and defining a set of requirements that can be validated once the software is built. Requirements modeling plays a crucial role in bridging the gap between a system-level representation that describes overall system and business functionality and a software design. By doing so, it enables the development of a software design that meets the customer's requirements and ensures that the software functions as intended. Furthermore, requirements modeling defines a set of requirements that can be validated once the software is built, allowing for the verification of the software's functionality and performance. This validation is essential in ensuring that the software meets the customer's needs and is free from defects, ultimately contributing to the success of the software development process.",
    "Student Answer": "To be honest, I'm not entirely sure about the primary objective of requirements modeling, but from what I've gathered, it's basically about creating a bunch of diagrams and documents that describe what the customer wants. I think it's supposed to help us understand the customer's requirements, but I'm not really clear on how it does that. \n\nI've heard that requirements modeling is important for software design, but I don't really get how it bridges the gap between system-level representation and software design. I mean, isn't software design just about writing code? I'm not sure how requirements modeling fits into that. Maybe it's like, a way to make sure we're building the right thing, but I'm not really sure.\n\nAs for validation, I think requirements modeling is supposed to help us define a set of requirements that we can check against once the software is built. But, to be honest, I'm not really sure how that works or why it's important. I know validation is a thing, but I don't really understand its significance in the software development process. Can we come back to this later? I feel like I'm missing something. \n\nOh, and I think requirements modeling might also have something to do with, like, making sure the software is usable and stuff. But, yeah, that's about it. I'm pretty lost on this topic, sorry.",
    "Strategy": "clarification"
     Please evaluate the student's answer by assigning a score from 0 to 10 and providing a concise review.
Return only this format:
Score: <score from 0 to 10>
Review: <your feedback>
"""}

]

response = tokenizer.apply_chat_template(chat, tokenize=False, add_generation_prompt=True)
inputs = tokenizer(response, return_tensors="pt").to(model.device)
inputs = {k: v for k, v in inputs.items() if k in ['input_ids', 'attention_mask']} # Remove token_type_ids if present

outputs = model.generate(**inputs, max_new_tokens=150) # Corrected from model_path.generate
print(tokenizer.decode(outputs[0], skip_special_tokens=True))

from google.colab import drive
drive.mount('/content/drive')
